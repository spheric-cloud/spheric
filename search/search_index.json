{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Spheric Documentation","text":"<p>This page contains the documentation of the spheric project which is part  of the spheric-cloud organization.</p>"},{"location":"api-reference/core/","title":"Core","text":"<p>Packages:</p> <ul> <li> core.spheric.cloud/v1alpha1 </li> </ul>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1","title":"core.spheric.cloud/v1alpha1","text":"<p>Package v1alpha1 is the v1alpha1 version of the API.</p> <p>Resource Types:</p> <ul><li> Disk </li><li> DiskType </li><li> Fleet </li><li> Instance </li><li> InstanceType </li><li> Network </li><li> Subnet </li></ul>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.Disk","title":"Disk","text":"<p>Disk is the Schema for the disks API</p> Field Description <code>apiVersion</code> string <code> core.spheric.cloud/v1alpha1 </code> <code>kind</code> string  <code>Disk</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  DiskSpec  <code>typeRef</code>  LocalObjectReference  <p>TypeRef references the DiskClass of the Disk.</p> <code>instanceRef</code>  LocalUIDReference  <p>InstanceRef references the using instance of the Disk.</p> <code>resources</code>  ResourceList  <p>Resources is a description of the Disk\u2019s resources and capacity.</p> <code>status</code>  DiskStatus"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.DiskType","title":"DiskType","text":"<p>DiskType is the Schema for the disktypes API.</p> Field Description <code>apiVersion</code> string <code> core.spheric.cloud/v1alpha1 </code> <code>kind</code> string  <code>DiskType</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field."},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.Fleet","title":"Fleet","text":"<p>Fleet is the Schema for the fleets API</p> Field Description <code>apiVersion</code> string <code> core.spheric.cloud/v1alpha1 </code> <code>kind</code> string  <code>Fleet</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  FleetSpec  <code>providerID</code>  string  <p>ProviderID identifies the Fleet on provider side.</p> <code>taints</code>  []Taint  <p>Taints of the Fleet. Only Machines who tolerate all the taints will land in the Fleet.</p> <code>status</code>  FleetStatus"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.Instance","title":"Instance","text":"<p>Instance is the Schema for the instances API</p> Field Description <code>apiVersion</code> string <code> core.spheric.cloud/v1alpha1 </code> <code>kind</code> string  <code>Instance</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  InstanceSpec  <code>instanceTypeRef</code>  LocalObjectReference  <p>InstanceTypeRef references the instance type of the instance.</p> <code>fleetSelector</code>  map[string]string  <p>FleetSelector selects a suitable Fleet by the given labels.</p> <code>fleetRef</code>  LocalObjectReference  <p>FleetRef defines the fleet to run the instance in. If empty, a scheduler will figure out an appropriate pool to run the instance in.</p> <code>power</code>  Power  <p>Power is the desired instance power state. Defaults to PowerOn.</p> <code>image</code>  string  (Optional) <p>Image is the optional URL providing the operating system image of the instance.</p> <code>imagePullSecret</code>  LocalObjectReference  <p>ImagePullSecretRef is an optional secret for pulling the image of a instance.</p> <code>networkInterfaces</code>  []NetworkInterface  (Optional) <p>NetworkInterfaces define a list of network interfaces present on the instance</p> <code>disks</code>  []AttachedDisk  (Optional) <p>Disks are the disks attached to this instance.</p> <code>ignitionRef</code>  SecretKeySelector  <p>IgnitionRef is a reference to a secret containing the ignition YAML for the instance to boot up. If key is empty, DefaultIgnitionKey will be used as fallback.</p> <code>efiVars</code>  []EFIVar  (Optional) <p>EFIVars are variables to pass to EFI while booting up.</p> <code>tolerations</code>  []Toleration  <p>Tolerations define tolerations the Instance has. Only fleets whose taints covered by Tolerations will be considered to run the Instance.</p> <code>status</code>  InstanceStatus"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.InstanceType","title":"InstanceType","text":"<p>InstanceType is the Schema for the instancetypes API</p> Field Description <code>apiVersion</code> string <code> core.spheric.cloud/v1alpha1 </code> <code>kind</code> string  <code>InstanceType</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>class</code>  InstanceTypeClass  <p>Class specifies the class of the InstanceType. Can either be \u2018Continuous\u2019 or \u2018Discrete\u2019.</p> <code>capabilities</code>  ResourceList  <p>Capabilities are the capabilities of the instance type.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.Network","title":"Network","text":"<p>Network is the Schema for the network API</p> Field Description <code>apiVersion</code> string <code> core.spheric.cloud/v1alpha1 </code> <code>kind</code> string  <code>Network</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  NetworkSpec  <code>status</code>  NetworkStatus"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.Subnet","title":"Subnet","text":"<p>Subnet is the Schema for the network API</p> Field Description <code>apiVersion</code> string <code> core.spheric.cloud/v1alpha1 </code> <code>kind</code> string  <code>Subnet</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  SubnetSpec  <code>networkRef</code>  LocalObjectReference  <p>NetworkRef references the network this subnet is part of.</p> <code>cidrs</code>  []string  <p>CIDRs are the primary CIDR ranges of this Subnet.</p> <code>status</code>  SubnetStatus"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.AttachedDisk","title":"AttachedDisk","text":"<p> (Appears on:InstanceSpec) </p> <p>AttachedDisk defines a disk attached to a instance.</p> Field Description <code>name</code>  string  <p>Name is the name of the disk.</p> <code>device</code>  string  <p>Device is the device name where the disk should be attached. Pointer to distinguish between explicit zero and not specified. If empty, an unused device name will be determined if possible.</p> <code>AttachedDiskSource</code>  AttachedDiskSource  <p> (Members of <code>AttachedDiskSource</code> are embedded into this type.) </p> <p>AttachedDiskSource is the source where the storage for the disk resides at.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.AttachedDiskSource","title":"AttachedDiskSource","text":"<p> (Appears on:AttachedDisk) </p> <p>AttachedDiskSource specifies the source to use for a disk.</p> Field Description <code>diskRef</code>  LocalObjectReference  <p>DiskRef instructs to use the specified Disk as source for the attachment.</p> <code>emptyDisk</code>  EmptyDiskSource  <p>EmptyDisk instructs to use a disk offered by the fleet provider.</p> <code>ephemeral</code>  EphemeralDiskSource  <p>Ephemeral instructs to create an ephemeral (i.e. coupled to the lifetime of the surrounding object) disk to use.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.AttachedDiskState","title":"AttachedDiskState (<code>string</code> alias)","text":"<p> (Appears on:AttachedDiskStatus) </p> <p>AttachedDiskState is the infrastructure attachment state a disk can be in.</p> Value Description <p>\"Attached\"</p> <p>AttachedDiskStateAttached indicates that a disk has been successfully attached.</p> <p>\"Pending\"</p> <p>AttachedDiskStatePending indicates that the attachment of a disk is pending.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.AttachedDiskStatus","title":"AttachedDiskStatus","text":"<p> (Appears on:InstanceStatus) </p> <p>AttachedDiskStatus is the status of a disk.</p> Field Description <code>name</code>  string  <p>Name is the name of the attached disk.</p> <code>state</code>  AttachedDiskState  <p>State represents the attachment state of a disk.</p> <code>lastStateTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastStateTransitionTime is the last time the State transitioned.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.ConfigMapKeySelector","title":"ConfigMapKeySelector","text":"<p>ConfigMapKeySelector is a reference to a specific \u2018key\u2019 within a ConfigMap resource. In some instances, <code>key</code> is a required field.</p> Field Description <code>name</code>  string  <p>Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</p> <code>key</code>  string  (Optional) <p>The key of the entry in the ConfigMap resource\u2019s <code>data</code> field to be used. Some instances of this field may be defaulted, in others it may be required.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.DaemonEndpoint","title":"DaemonEndpoint","text":"<p> (Appears on:FleetDaemonEndpoints) </p> <p>DaemonEndpoint contains information about a single Daemon endpoint.</p> Field Description <code>port</code>  int32  <p>Port number of the given endpoint.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.DiskAccess","title":"DiskAccess","text":"<p> (Appears on:DiskStatus) </p> Field Description <code>driver</code>  string  <p>Driver is the name of the drive to use for this volume. Required.</p> <code>handle</code>  string  <p>Handle is the unique handle of the volume.</p> <code>attributes</code>  map[string]string  <p>Attributes are attributes of the volume to use.</p> <code>secretRef</code>  LocalObjectReference  <p>SecretRef references the (optional) secret containing the data to access the Disk.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.DiskSpec","title":"DiskSpec","text":"<p> (Appears on:Disk, DiskTemplateSpec) </p> <p>DiskSpec defines the desired state of Disk</p> Field Description <code>typeRef</code>  LocalObjectReference  <p>TypeRef references the DiskClass of the Disk.</p> <code>instanceRef</code>  LocalUIDReference  <p>InstanceRef references the using instance of the Disk.</p> <code>resources</code>  ResourceList  <p>Resources is a description of the Disk\u2019s resources and capacity.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.DiskState","title":"DiskState (<code>string</code> alias)","text":"<p> (Appears on:DiskStatus) </p> <p>DiskState represents the infrastructure state of a Disk.</p> Value Description <p>\"Available\"</p> <p>DiskStateAvailable reports whether a Disk is available to be used.</p> <p>\"Error\"</p> <p>DiskStateError reports that a Disk is in an error state.</p> <p>\"Pending\"</p> <p>DiskStatePending reports whether a Disk is about to be ready.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.DiskStatus","title":"DiskStatus","text":"<p> (Appears on:Disk) </p> <p>DiskStatus defines the observed state of Disk</p> Field Description <code>state</code>  DiskState  <p>State represents the infrastructure state of a Disk.</p> <code>access</code>  DiskAccess  <p>Access contains information to access the Disk. Must be set when Disk is in DiskStateAvailable.</p> <code>lastStateTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastStateTransitionTime is the last time the State transitioned between values.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.DiskTemplateSpec","title":"DiskTemplateSpec","text":"<p> (Appears on:EphemeralDiskSource) </p> <p>DiskTemplateSpec is the specification of a Disk template.</p> Field Description <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  DiskSpec  <code>typeRef</code>  LocalObjectReference  <p>TypeRef references the DiskClass of the Disk.</p> <code>instanceRef</code>  LocalUIDReference  <p>InstanceRef references the using instance of the Disk.</p> <code>resources</code>  ResourceList  <p>Resources is a description of the Disk\u2019s resources and capacity.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.EFIVar","title":"EFIVar","text":"<p> (Appears on:InstanceSpec) </p> <p>EFIVar is a variable to pass to EFI while booting up.</p> Field Description <code>name</code>  string  <p>Name is the name of the EFIVar.</p> <code>uuid</code>  string  <p>UUID is the uuid of the EFIVar.</p> <code>value</code>  string  <p>Value is the value of the EFIVar.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.EmptyDiskSource","title":"EmptyDiskSource","text":"<p> (Appears on:AttachedDiskSource) </p> <p>EmptyDiskSource is a disk that\u2019s offered by the fleet provider. Usually ephemeral (i.e. deleted when the surrounding entity is deleted), with varying performance characteristics. Potentially not recoverable.</p> Field Description <code>sizeLimit</code>  k8s.io/apimachinery/pkg/api/resource.Quantity  <p>SizeLimit is the total amount of local storage required for this EmptyDisk disk. The default is nil which means that the limit is undefined.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.EphemeralDiskSource","title":"EphemeralDiskSource","text":"<p> (Appears on:AttachedDiskSource) </p> <p>EphemeralDiskSource is a definition for an ephemeral (i.e. coupled to the lifetime of the surrounding object) disk.</p> Field Description <code>diskTemplate</code>  DiskTemplateSpec  <p>DiskTemplate is the template definition of a Disk.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.FleetAddress","title":"FleetAddress","text":"<p> (Appears on:FleetStatus) </p> Field Description <code>type</code>  FleetAddressType  <code>address</code>  string"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.FleetAddressType","title":"FleetAddressType (<code>string</code> alias)","text":"<p> (Appears on:FleetAddress) </p> Value Description <p>\"ExternalDNS\"</p> <p>FleetExternalDNS identifies a DNS name which resolves to an IP address which has the characteristics of FleetExternalIP. The IP it resolves to may or may not be a listed MachineExternalIP address.</p> <p>\"ExternalIP\"</p> <p>FleetExternalIP identifies an IP address which is, in some way, intended to be more usable from outside the cluster than an internal IP, though no specific semantics are defined.</p> <p>\"Hostname\"</p> <p>FleetHostName identifies a name of the fleet. Although every fleet can be assumed to have a FleetAddress of this type, its exact syntax and semantics are not defined, and are not consistent between different clusters.</p> <p>\"InternalDNS\"</p> <p>FleetInternalDNS identifies a DNS name which resolves to an IP address which has the characteristics of a FleetInternalIP. The IP it resolves to may or may not be a listed FleetInternalIP address.</p> <p>\"InternalIP\"</p> <p>FleetInternalIP identifies an IP address which may not be visible to hosts outside the cluster. By default, it is assumed that apiserver can reach fleet internal IPs, though it is possible to configure clusters where this is not the case.</p> <p>FleetInternalIP is the default type of fleet IP, and does not necessarily imply that the IP is ONLY reachable internally. If a fleet has multiple internal IPs, no specific semantics are assigned to the additional IPs.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.FleetCondition","title":"FleetCondition","text":"<p> (Appears on:FleetStatus) </p> <p>FleetCondition is one of the conditions of a disk.</p> Field Description <code>type</code>  FleetConditionType  <p>Type is the type of the condition.</p> <code>status</code>  Kubernetes core/v1.ConditionStatus  <p>Status is the status of the condition.</p> <code>reason</code>  string  <p>Reason is a machine-readable indication of why the condition is in a certain state.</p> <code>message</code>  string  <p>Message is a human-readable explanation of why the condition has a certain reason / state.</p> <code>observedGeneration</code>  int64  <p>ObservedGeneration represents the .metadata.generation that the condition was set based upon.</p> <code>lastTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastTransitionTime is the last time the status of a condition has transitioned from one state to another.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.FleetConditionType","title":"FleetConditionType (<code>string</code> alias)","text":"<p> (Appears on:FleetCondition) </p> <p>FleetConditionType is a type a FleetCondition can have.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.FleetDaemonEndpoints","title":"FleetDaemonEndpoints","text":"<p> (Appears on:FleetStatus) </p> <p>FleetDaemonEndpoints lists ports opened by daemons running on the Fleet.</p> Field Description <code>sphereletEndpoint</code>  DaemonEndpoint  (Optional) <p>Endpoint on which spherelet is listening.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.FleetSpec","title":"FleetSpec","text":"<p> (Appears on:Fleet) </p> <p>FleetSpec defines the desired state of Fleet</p> Field Description <code>providerID</code>  string  <p>ProviderID identifies the Fleet on provider side.</p> <code>taints</code>  []Taint  <p>Taints of the Fleet. Only Machines who tolerate all the taints will land in the Fleet.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.FleetState","title":"FleetState (<code>string</code> alias)","text":"<p> (Appears on:FleetStatus) </p> <p>FleetState is a state a Fleet can be in.</p> Value Description <p>\"Error\"</p> <p>FleetStateError marks a Fleet in an error state.</p> <p>\"Offline\"</p> <p>FleetStateOffline marks a Fleet as offline.</p> <p>\"Pending\"</p> <p>FleetStatePending marks a Fleet as pending readiness.</p> <p>\"Ready\"</p> <p>FleetStateReady marks a Fleet as ready for accepting a Machine.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.FleetStatus","title":"FleetStatus","text":"<p> (Appears on:Fleet) </p> <p>FleetStatus defines the observed state of Fleet</p> Field Description <code>state</code>  FleetState  <code>conditions</code>  []FleetCondition  <code>addresses</code>  []FleetAddress  <code>daemonEndpoints</code>  FleetDaemonEndpoints  <code>capacity</code>  ResourceList  <p>Capacity represents the total resources of a fleet.</p> <code>allocatable</code>  ResourceList  <p>Allocatable represents the resources of a fleet that are available for scheduling.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.InstanceExecOptions","title":"InstanceExecOptions","text":"<p>InstanceExecOptions is the query options to a Instance\u2019s remote exec call</p> Field Description <code>insecureSkipTLSVerifyBackend</code>  bool"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.InstanceSpec","title":"InstanceSpec","text":"<p> (Appears on:Instance) </p> <p>InstanceSpec defines the desired state of Instance</p> Field Description <code>instanceTypeRef</code>  LocalObjectReference  <p>InstanceTypeRef references the instance type of the instance.</p> <code>fleetSelector</code>  map[string]string  <p>FleetSelector selects a suitable Fleet by the given labels.</p> <code>fleetRef</code>  LocalObjectReference  <p>FleetRef defines the fleet to run the instance in. If empty, a scheduler will figure out an appropriate pool to run the instance in.</p> <code>power</code>  Power  <p>Power is the desired instance power state. Defaults to PowerOn.</p> <code>image</code>  string  (Optional) <p>Image is the optional URL providing the operating system image of the instance.</p> <code>imagePullSecret</code>  LocalObjectReference  <p>ImagePullSecretRef is an optional secret for pulling the image of a instance.</p> <code>networkInterfaces</code>  []NetworkInterface  (Optional) <p>NetworkInterfaces define a list of network interfaces present on the instance</p> <code>disks</code>  []AttachedDisk  (Optional) <p>Disks are the disks attached to this instance.</p> <code>ignitionRef</code>  SecretKeySelector  <p>IgnitionRef is a reference to a secret containing the ignition YAML for the instance to boot up. If key is empty, DefaultIgnitionKey will be used as fallback.</p> <code>efiVars</code>  []EFIVar  (Optional) <p>EFIVars are variables to pass to EFI while booting up.</p> <code>tolerations</code>  []Toleration  <p>Tolerations define tolerations the Instance has. Only fleets whose taints covered by Tolerations will be considered to run the Instance.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.InstanceState","title":"InstanceState (<code>string</code> alias)","text":"<p> (Appears on:InstanceStatus) </p> <p>InstanceState is the state of a instance.</p> Value Description <p>\"Pending\"</p> <p>InstanceStatePending means the Instance has been accepted by the system, but not yet completely started. This includes time before being bound to a Fleet, as well as time spent setting up the Instance on that Fleet.</p> <p>\"Running\"</p> <p>InstanceStateRunning means the instance is running on a Fleet.</p> <p>\"Shutdown\"</p> <p>InstanceStateShutdown means the instance is shut down.</p> <p>\"Terminated\"</p> <p>InstanceStateTerminated means the instance has been permanently stopped and cannot be started.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.InstanceStatus","title":"InstanceStatus","text":"<p> (Appears on:Instance) </p> <p>InstanceStatus defines the observed state of Instance</p> Field Description <code>instanceID</code>  string  <p>InstanceID is the provider specific instance ID in the format \u2018://\u2019. <code>observedGeneration</code>  int64  <p>ObservedGeneration is the last generation the Fleet observed of the Instance.</p> <code>state</code>  InstanceState  <p>State is the infrastructure state of the instance.</p> <code>networkInterfaces</code>  []NetworkInterfaceStatus  <p>NetworkInterfaces is the list of network interface states for the instance.</p> <code>disks</code>  []AttachedDiskStatus  <p>Disks is the list of disk states for the instance.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.InstanceTypeClass","title":"InstanceTypeClass (<code>string</code> alias)","text":"<p> (Appears on:InstanceType) </p> <p>InstanceTypeClass denotes the type of InstanceType.</p> Value Description <p>\"Continuous\"</p> <p>\"Discrete\"</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.LocalObjectReference","title":"LocalObjectReference","text":"<p> (Appears on:AttachedDiskSource, DiskAccess, DiskSpec, InstanceSpec, SubnetSpec) </p> <p>LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.</p> Field Description <code>name</code>  string  <p>Name of the referent.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.LocalUIDReference","title":"LocalUIDReference","text":"<p> (Appears on:DiskSpec) </p> <p>LocalUIDReference is a reference to another entity including its UID</p> Field Description <code>name</code>  string  <p>Name is the name of the referenced entity.</p> <code>uid</code>  k8s.io/apimachinery/pkg/types.UID  <p>UID is the UID of the referenced entity.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.NetworkInterface","title":"NetworkInterface","text":"<p> (Appears on:InstanceSpec) </p> <p>NetworkInterface is the definition of a single interface</p> Field Description <code>name</code>  string  <p>Name is the name of the network interface.</p> <code>subnetRef</code>  SubnetReference  <p>SubnetRef references the Subnet this NetworkInterface is connected to</p> <code>ipFamilies</code>  []Kubernetes core/v1.IPFamily  <p>IPFamilies defines which IPFamilies this NetworkInterface is supporting</p> <code>ips</code>  []string  <p>IPs are the literal requested IPs for this NetworkInterface.</p> <code>accessIPFamilies</code>  []Kubernetes core/v1.IPFamily  <p>AccessIPFamilies are the access configuration IP families.</p> <code>accessIPs</code>  []string  <p>AccessIPs are the literal request access IPs.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.NetworkInterfaceState","title":"NetworkInterfaceState (<code>string</code> alias)","text":"<p> (Appears on:NetworkInterfaceStatus) </p> <p>NetworkInterfaceState is the infrastructure attachment state a NetworkInterface can be in.</p> Value Description <p>\"Attached\"</p> <p>NetworkInterfaceStateAttached indicates that a network interface has been successfully attached.</p> <p>\"Pending\"</p> <p>NetworkInterfaceStatePending indicates that the attachment of a network interface is pending.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.NetworkInterfaceStatus","title":"NetworkInterfaceStatus","text":"<p> (Appears on:InstanceStatus) </p> <p>NetworkInterfaceStatus reports the status of an NetworkInterfaceSource.</p> Field Description <code>name</code>  string  <p>Name is the name of the NetworkInterface to whom the status belongs to.</p> <code>ips</code>  []string  <p>IPs are the ips allocated for the network interface.</p> <code>accessIPs</code>  []string  <p>AccessIPs are the allocated access IPs for the network interface.</p> <code>state</code>  NetworkInterfaceState  <p>State represents the attachment state of a NetworkInterface.</p> <code>lastStateTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastStateTransitionTime is the last time the State transitioned.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.NetworkSpec","title":"NetworkSpec","text":"<p> (Appears on:Network) </p> <p>NetworkSpec defines the desired state of Network</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.NetworkState","title":"NetworkState (<code>string</code> alias)","text":"<p> (Appears on:NetworkStatus) </p> <p>NetworkState is the state of a network.</p> Value Description <p>\"Available\"</p> <p>NetworkStateAvailable means the network is ready to use.</p> <p>\"Error\"</p> <p>NetworkStateError means the network is in an error state.</p> <p>\"Pending\"</p> <p>NetworkStatePending means the network is being provisioned.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.NetworkStatus","title":"NetworkStatus","text":"<p> (Appears on:Network) </p> <p>NetworkStatus defines the observed state of Network</p> Field Description <code>state</code>  NetworkState  <p>State is the state of the machine.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.ObjectSelector","title":"ObjectSelector","text":"<p>ObjectSelector specifies how to select objects of a certain kind.</p> Field Description <code>kind</code>  string  <p>Kind is the kind of object to select.</p> <code>LabelSelector</code>  Kubernetes meta/v1.LabelSelector  <p> (Members of <code>LabelSelector</code> are embedded into this type.) </p> <p>LabelSelector is the label selector to select objects of the specified Kind by.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.Power","title":"Power (<code>string</code> alias)","text":"<p> (Appears on:InstanceSpec) </p> <p>Power is the desired power state of a Instance.</p> Value Description <p>\"Off\"</p> <p>PowerOff indicates that a Instance should be powered off.</p> <p>\"On\"</p> <p>PowerOn indicates that a Instance should be powered on.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.ResourceName","title":"ResourceName (<code>string</code> alias)","text":"<p>ResourceName is the name of a resource, most often used alongside a resource.Quantity.</p> Value Description <p>\"cpu\"</p> <p>ResourceCPU is the amount of cpu in cores.</p> <p>\"iops\"</p> <p>ResourceIOPS defines max IOPS in input/output operations per second.</p> <p>\"memory\"</p> <p>ResourceMemory is the amount of memory in bytes.</p> <p>\"storage\"</p> <p>ResourceStorage is the amount of storage, in bytes.</p> <p>\"tps\"</p> <p>ResourceTPS defines max throughput per second. (e.g. 1Gi)</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.SecretKeySelector","title":"SecretKeySelector","text":"<p> (Appears on:InstanceSpec) </p> <p>SecretKeySelector is a reference to a specific \u2018key\u2019 within a Secret resource. In some instances, <code>key</code> is a required field.</p> Field Description <code>name</code>  string  <p>Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</p> <code>key</code>  string  (Optional) <p>The key of the entry in the Secret resource\u2019s <code>data</code> field to be used. Some instances of this field may be defaulted, in others it may be required.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.SubnetReference","title":"SubnetReference","text":"<p> (Appears on:NetworkInterface) </p> Field Description <code>networkName</code>  string  <p>NetworkName is the name of the referenced network.</p> <code>name</code>  string  <p>Name of the referenced subnet.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.SubnetSpec","title":"SubnetSpec","text":"<p> (Appears on:Subnet) </p> <p>SubnetSpec defines the desired state of Subnet</p> Field Description <code>networkRef</code>  LocalObjectReference  <p>NetworkRef references the network this subnet is part of.</p> <code>cidrs</code>  []string  <p>CIDRs are the primary CIDR ranges of this Subnet.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.SubnetState","title":"SubnetState (<code>string</code> alias)","text":"<p> (Appears on:SubnetStatus) </p> <p>SubnetState is the state of a network.</p> Value Description <p>\"Available\"</p> <p>SubnetStateAvailable means the network is ready to use.</p> <p>\"Error\"</p> <p>SubnetStateError means the network is in an error state.</p> <p>\"Pending\"</p> <p>SubnetStatePending means the network is being provisioned.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.SubnetStatus","title":"SubnetStatus","text":"<p> (Appears on:Subnet) </p> <p>SubnetStatus defines the observed state of Subnet</p> Field Description <code>state</code>  SubnetState  <p>State is the state of the machine.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.Taint","title":"Taint","text":"<p> (Appears on:FleetSpec) </p> <p>Taint marks an effect with a value on a target resource pool.</p> Field Description <code>key</code>  string  <p>The taint key to be applied to a resource pool.</p> <code>value</code>  string  <p>The taint value corresponding to the taint key.</p> <code>effect</code>  TaintEffect  <p>The effect of the taint on resources that do not tolerate the taint. Valid effects are NoSchedule, PreferNoSchedule and NoExecute.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.TaintEffect","title":"TaintEffect (<code>string</code> alias)","text":"<p> (Appears on:Taint, Toleration) </p> Value Description <p>\"NoSchedule\"</p> <p>TaintEffectNoSchedule causes not to allow new resources to schedule onto the resource pool unless they tolerate the taint, but allow all already-running resources to continue running. Enforced by the scheduler.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.Toleration","title":"Toleration","text":"<p> (Appears on:InstanceSpec) </p> <p>Toleration marks the resource the toleration is attached to tolerate any taint that matches the triple  using the matching operator . Field Description <code>key</code>  string  <p>Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.</p> <code>operator</code>  TolerationOperator  <p>Operator represents a key\u2019s relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a resource can tolerate all taints of a particular category.</p> <code>value</code>  string  <p>Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.</p> <code>effect</code>  TaintEffect  <p>Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule.</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.TolerationOperator","title":"TolerationOperator (<code>string</code> alias)","text":"<p> (Appears on:Toleration) </p> <p>TolerationOperator is the set of operators that can be used in a toleration.</p> Value Description <p>\"Equal\"</p> <p>\"Exists\"</p>"},{"location":"api-reference/core/#core.spheric.cloud/v1alpha1.UIDReference","title":"UIDReference","text":"<p>UIDReference is a reference to another entity in a potentially different namespace including its UID.</p> Field Description <code>namespace</code>  string  <p>Namespace is the namespace of the referenced entity. If empty, the same namespace as the referring resource is implied.</p> <code>name</code>  string  <p>Name is the name of the referenced entity.</p> <code>uid</code>  k8s.io/apimachinery/pkg/types.UID  <p>UID is the UID of the referenced entity.</p> <p> Generated with <code>gen-crd-api-reference-docs</code> </p>"},{"location":"api-reference/overview/","title":"API Reference Documentation","text":"<p>This is the home of the API reference documentation grouped by the various API groups. The content in each subgroup is automatically generated from the Go types in the <code>apis</code> folder. For more information on how the documentation is built and how it can be updated please refer to the Updating API Reference Documentation in the documentation development guide.</p> <ul> <li>Core</li> </ul>"},{"location":"concepts/machine-exec-flow/","title":"Instance Exec","text":"<p>The <code>exec</code> feature allows accessing the serial console of an <code>Instance</code> via the <code>apiserver</code>. The following parties are involved in implementing <code>exec</code>:</p> <ul> <li><code>apiserver</code></li> <li><code>spherelet</code></li> <li><code>iri</code> implementor</li> </ul> <p>The connection flow between those components looks like the following:</p> <pre><code>sequenceDiagram\n    participant User as user\n    participant API as apiserver\n    participant SP as spherelet\n    participant IRI as iri implementor\n\n    User-&gt;&gt;API: exec request with instance name\n    Note over API: Get instance by name\n    Note over API: Get fleet\n    Note over API: Find suitable address &amp; port\n    Note over API: Create URL for exec request\n    API-&gt;&gt;SP: HTTP request to exec URL\n    Note over SP: Check authentication &amp; authorization\n    SP-&gt;&gt;IRI: Call Exec method\n    Note over IRI: Provide functioning Exec implementation\n    Note over IRI: iri implementor generates unique token\n    Note over IRI: Token-associated URL is called\n    Note over IRI: Calls exec on its target\n    Note over IRI: Proxies response from the apiserver to the requester\n    IRI--&gt;&gt;SP: Returns URL for exec session\n    SP--&gt;&gt;API: Proxy response\n    API--&gt;&gt;User: Proxy response</code></pre>"},{"location":"concepts/machine-exec-flow/#spheric-apiserver","title":"<code>spheric-apiserver</code>","text":"<p>The <code>spheric-apiserver</code> implements <code>exec</code> as a custom subresource on the <code>Machine</code> resource. In the <code>spheric</code> REST registry, it is registered as <code>machines/exec</code>.</p> <p>The subresource itself is implemented by implementing the <code>k8s.io/apiserver/pkg/registry/rest.Connecter</code> interface, which allows custom logic for handling <code>CONNECT</code> and their follow-up <code>GET</code> / <code>POST</code> requests.</p> <p>For <code>exec</code>, the <code>spheric-apiserver</code> knows the name of the machine the user wants to access. It first gets the machine by its name (returning an error if it doesn't exist) and then the machine pool it's assigned to (also returning an error if the machine is not assigned to any pool or the machine pool does not exist).</p> <p>On the machine pool, it looks for a suitable address via the reported <code>MachinePool.Status.Addresses</code>, depending on the configurable preferred address types of the <code>spheric-apiserver</code>. Once found, it uses the address together with the <code>MachinePool.Status.DaemonEndpoints.MachinepoolletEndpoint.Port</code> to create a URL to make the target <code>exec</code> request to. The URL is of the form</p> <pre><code>https://&lt;host&gt;:&lt;port&gt;/apis/core.spheric.cloud/namespaces/&lt;namespace&gt;/machines/&lt;machine/exec\n</code></pre> <p>It then makes an http request to that location and proxies the resulting response to the original requester.</p>"},{"location":"concepts/machine-exec-flow/#machinepoollet","title":"<code>machinepoollet</code>","text":"<p>The <code>machinepoollet</code> provides the HTTP server wrapping the <code>iri-machine</code> implementor. This HTTP server also provides the aforementioned route to serve <code>exec</code> for a machine.</p> <p>When the <code>machinepoollet</code> gets a request to that URL it first checks whether the requesting entity is authenticated &amp; authorized to do an <code>exec</code> request for that machine. It does so by using a delegated authenticator / authorizer against the <code>kube-apiserver</code> the <code>spheric-apiserver</code> is connected to.</p> <p>Once successfully authenticated &amp; authorized, the <code>machinepoollet</code> calls the <code>Exec</code> method of the <code>iri-machine</code> implementor. This <code>Exec</code> method returns a URL where the <code>exec</code> session for the target machine will be hosted at.</p> <p>It then makes an HTTP request to that URL and proxies the resulting response to the <code>spheric-apiserver</code>.</p>"},{"location":"concepts/machine-exec-flow/#iri-machine-implementor","title":"<code>iri-machine</code> Implementor","text":"<p>The <code>iri-machine</code> implementor has to provide a functioning <code>Exec</code> implementation that returns the URL where the actual <code>exec</code> session of the machine is hosted at.</p> <p>For the <code>machinebroker</code>, this is implemented by having an HTTP server that associates the request together with a unique randomly generated token and returns a URL containing that token.</p> <p>Once the URL containing that token is called, the <code>machinebroker</code> looks up the corresponding request and calls <code>exec</code> on its target (different from the original) <code>spheric-apiserver</code> with the machine namespace and name from the stored request. It then proxies the response from the <code>spheric-apiserver</code> to the requester.</p>"},{"location":"development/contribution/","title":"Contributors Guide","text":""},{"location":"development/contribution/#contributing","title":"Contributing","text":"<p>The Spheric project uses Github to manage reviews of pull requests.</p> <ul> <li> <p>If you are looking to make your first contribution, follow Steps to Contribute</p> </li> <li> <p>If you have a trivial fix or improvement, go ahead and create a pull request and address (with @...) a suitable maintainer of this repository  (see CODEOWNERS  of this repository) in the description of the pull request.</p> </li> <li> <p>If you plan to do something more involved, first discuss your ideas by creating an  issue for this repository. This will avoid unnecessary work and surely give you  and us a good deal of inspiration.</p> </li> </ul> <p>Note</p> <p>Please follow these style guidelines to have your contribution considered by the maintainers: Coding style guidelines Go Code Review Comments, Formatting and style section of Peter Bourgon\u2019s Go: Best Practices for Production Environments.</p>"},{"location":"development/contribution/#steps-to-contribute","title":"Steps to Contribute","text":"<p>Do you want to work on an issue?  You are welcome to claim an existing one by commenting on it in GitHub. </p> <p>Note</p> <p>Perform a cursory search to see if the issue has already been taken by someone else.  This will prevent misunderstanding and duplication of  effort from contributors on the same issue.</p> <p>If you have questions about one of the issues please comment on them and one of the  maintainers will clarify it.</p> <p>We kindly ask you to follow the Pull Request Checklist to ensure reviews can happen accordingly.</p>"},{"location":"development/contribution/#contributing-code","title":"Contributing Code","text":"<p>You are welcome to contribute code to the Spheric project in order to fix a bug or to implement a new feature.</p> <p>The following rules govern code contributions:</p> <ul> <li>Contributions must be licensed under the Apache 2.0 License</li> <li>You need to sign the Developer Certificate of Origin.</li> </ul>"},{"location":"development/contribution/#contributing-documentation","title":"Contributing Documentation","text":"<p>You are welcome to contribute documentation to the Spheric project.</p> <p>The following rules govern documentation contributions:</p> <ul> <li>Contributions must be licensed under the Creative Commons Attribution 4.0 International License</li> <li>You need to sign the Developer Certificate of Origin.</li> </ul>"},{"location":"development/contribution/#developer-certificate-of-origin","title":"Developer Certificate of Origin","text":"<p>Due to legal reasons, contributors will be asked to accept a Developer Certificate of Origin (DCO) before they submit  the first pull request to the Spheric project, this happens in an automated fashion during the submission  process. We use the standard DCO text of the Linux Foundation.</p>"},{"location":"development/contribution/#pull-request-checklist","title":"Pull Request Checklist","text":"<ul> <li>Fork and clone the repository to you local machine.</li> </ul> <pre><code>git clone git@github.com:YOUR_GITHUB_USER/spheric.git\ncd spheric\n</code></pre> <ul> <li>Create a branch from the <code>main</code>  using 'git checkout' command. </li> </ul> <p>Note</p> <p>If needed, rebase to the current <code>main</code> branch before submitting  your pull request. If it doesn't merge properly with <code>main</code> you may be asked to rebase your changes.</p> <pre><code>git checkout -b my_feature\n# rebase if necessary\ngit fetch upstream main\ngit rebase upstream/main\n</code></pre> <ul> <li> <p>Commits should be as small as possible, while ensuring that each commit is correct independently  (i.e. each commit should compile and pass tests).</p> </li> <li> <p>Create your patch and test your changes  before you commit them. Automated test by unit / integration tests are preferred.  If tested manually, provide information about the test scope in the PR description. Now you can commit your changes to your feature branch and push it to your fork.</p> </li> </ul> <pre><code>git add .\ngit commit -m \"Something meaningful\"\ngit push origin my_feature\n</code></pre> <p>Note</p> <p>Alternatively you can amend your commit before pushing if you forgot something by using <code>git commit --amend</code></p> <ul> <li> <p>Create Work In Progress [WIP] pull requests only if you need a clarification or an explicit review before you can  continue your work item.</p> </li> <li> <p>If your patch is not getting reviewed, or you need a specific person to review it, you can @-reply a reviewer asking  for a review in the pull request or a comment.</p> </li> <li> <p>Post review:</p> <ul> <li>If a reviewer requires you to change your commit(s), please test the changes again.</li> <li>Amend the affected commit(s) and force push onto your branch.</li> <li>Set respective comments in your GitHub review as resolved.</li> <li>Create a general PR comment to notify the reviewers that your amendments are ready for another round of review.</li> </ul> </li> </ul>"},{"location":"development/contribution/#issues-and-planning","title":"Issues and Planning","text":"<p>We use GitHub issues to track bugs and enhancement requests. Please provide as much context as possible when you open  an issue. The information you provide must be comprehensive enough to understand, reproduce the behavior and find related reports of  that issue for the assignee.  Therefore, contributors may use but aren't restricted to the issue template provided by the Spheric maintainers.</p> <p>Issues and pull requests are tracked in the backlog for this project.</p>"},{"location":"development/documentation/","title":"Documentation Setup","text":"<p>The documentation of the spheric project is written primarily using Markdown. All documentation related content can be found in the <code>/docs</code> folder. New content also should be added there. MkDocs and MkDocs Material are then used to render the contents of the <code>/docs</code> folder to have a more user-friendly experience when browsing the projects' documentation.</p> <p>Note</p> <p>One exception to the common contribution process builds the <code>docs/api-reference</code> folder. The folder contains auto-generated CRD reference documentation of the project, no manual contributions should be applied as they will be overwritten in the next generation step. To read more: Updating API Reference Documentation  section.</p>"},{"location":"development/documentation/#requirements","title":"Requirements:","text":"<p>Following tools are required to work on that package.</p> <ul> <li>Kubernetes cluster access to deploy and test the result (via minikube, kind or docker desktop locally)</li> <li>make - to execute build goals</li> <li>docker - to run the local mkdocs environment</li> <li>git - to be able to commit any changes to repository</li> <li>kubectl (&gt;= v1.23.4) - to be able to talk to the kubernetes cluster</li> </ul> <p>Note</p> <p>If you don't have Docker installed on your machine please follow one of those guides:</p> <ul> <li>Docker Desktop for Mac</li> <li>Docker Desktop for Windows</li> <li>Docker Engine for Linux</li> </ul>"},{"location":"development/documentation/#local-development-setup","title":"Local Development Setup","text":"<p>This project contains a local Docker based runtime environment for the documentation part. If you have an access to the docker registry and k8s installation that you can use for development purposes, just run following command and access the output in your browser under http://localhost:8000/:</p> <p><pre><code>make start-docs\n</code></pre> The environment will hot-rebuild your documentation, so there is no need to restart it while you make your changes. If you want to add a new chapter (basically a new file/folder to <code>docs</code> directory) you should add it to the <code>nav</code> section in the <code>mkdocs.yml</code> file in the projects root folder. Use helper Makefile directive to clean up old and stopped container instances.</p> <pre><code>make clean-docs\n</code></pre>"},{"location":"development/documentation/#writing-content","title":"Writing Content","text":""},{"location":"development/documentation/#abbreviations","title":"Abbreviations","text":"<p>Abbreviations are defined centrally in the following file <code>/hack/docs/abbreviations.md</code>. In case you introduce any new abbreviation to your content, please make sure to add a corresponding entry there. Please include the statement <code>--8&lt;-- \"hack/docs/abbreviations.md\"</code> at the end of each Markdown file. This will ensure that the abbreviation highlighting will work correctly.</p>"},{"location":"development/documentation/#api-reference-documentation","title":"API Reference Documentation","text":"<p>The API reference documentation contains auto-generated description from the CRD definition of the spheric project. We are using the gen-crd-api-reference-docs project to generate the content. Under the hood we are using <code>go generate</code> instructions defined in each version type <code>doc.go</code>. The needed instructions to generate documentation for the <code>core/v1alpha1</code> types are in the example below:</p> <p><pre><code>//go:generate gen-crd-api-reference-docs -api-dir . -config ../../../hack/api-reference/core-config.json -template-dir ../../../hack/api-reference/template -out-file ../../../docs/api-reference/core.md\n</code></pre> Together with the comments in the corresponding type files <code>go generate</code> will call the <code>gen-crd-api-reference-doc</code> command to generate the output in the <code>/docs/api-reference</code> folder. The project contains a <code>Makefile</code> routine to generate the reference documentation for all types. In case you change any of the types in the <code>apis</code> folder just run:</p> <pre><code>make docs\n</code></pre> <p>Note</p> <p>The generated output should be part of your pull request.</p>"},{"location":"development/setup/","title":"Local Development Setup","text":""},{"location":"development/setup/#requirements","title":"Requirements","text":"<ul> <li><code>go</code> &gt;= 1.20</li> <li><code>git</code>, <code>make</code> and <code>kubectl</code></li> <li>Kustomize</li> <li>Access to a Kubernetes cluster (Minikube, kind or a   real cluster)</li> </ul>"},{"location":"development/setup/#clone-the-repository","title":"Clone the Repository","text":"<p>To bring up and start locally the <code>spheric</code> project for development purposes you first need to clone the repository.</p> <pre><code>git clone git@github.com:spheric-cloud/spheric.git\ncd spheric\n</code></pre>"},{"location":"development/setup/#install-cert-manager","title":"Install cert-manager","text":"<p>If there is no cert-manager present in the cluster it needs to be installed.</p> <pre><code>kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.yaml\n</code></pre>"},{"location":"development/setup/#install-apis-into-the-cluster","title":"Install APIs into the Cluster","text":"<p>Your Kubernetes API server needs to know about the APIs which come with the <code>spheric</code> project. To install the APIs your cluster, run</p> <pre><code>make install\n</code></pre> <p>Note: This requires the <code>APISERVER_IMG</code> (Makefile default set to <code>apiserver</code>) to be pullable from your kubernetes cluster. For local development with <code>kind</code>, a make target that builds and loads the api server image and then applies the manifests is available via</p> <pre><code>make kind-install\n</code></pre> <p>Note: In case that there are multiple environments running, ensure that <code>kind get clusters</code> is pointing to the default kind cluster.</p>"},{"location":"development/setup/#start-the-controller-manager","title":"Start the Controller Manager","text":"<p>The controller manager can be started via the following command</p> <pre><code>make run\n</code></pre>"},{"location":"development/setup/#apply-sample-manifests","title":"Apply Sample Manifests","text":"<p>The <code>config/samples</code> folder contains samples for all APIs supported by this project. You can apply any of the samples by running</p> <pre><code>kubectl apply -f config/samples/SOME_RESOURCE.yaml\n</code></pre>"},{"location":"development/setup/#rebuilding-api-type-and-manifests","title":"Rebuilding API Type and Manifests","text":"<p>Everytime a change has been done to any of the types definitions, the corresponding manifests and generated code pieces have to be rebuilt.</p> <pre><code>make generate\nmake manifests\n</code></pre> <p>Note: Make sure your APIs are up-to-date by running <code>make install</code> / <code>make kind-install</code> after your code / manifests have been regenerated.</p>"},{"location":"development/setup/#setup-formatting-tools","title":"Setup formatting tools","text":"<p>The project uses <code>gofmt</code> and <code>goimports</code> for formatting. <code>gofmt</code> is used with default settings. While <code>goimports</code> should be used with <code>--local github.com/spheric-cloud</code> flag, so that <code>goimports</code> would sort <code>spheric</code> pkgs separately.</p> <p>You can automate running formatting tools in your IDE.</p> <ul> <li>VSCode -- add following to the <code>settings.json</code>:</li> </ul> <pre><code>    \"go.formatTool\": \"goimports\",\n    \"gopls\": {\n        \"formatting.local\": \"github.com/spheric-cloud\",\n    },\n</code></pre> <ul> <li>Goland -- go to <code>File -&gt; Settings -&gt; Tools -&gt; File Watchers</code> and replace contents of <code>Arguments</code>   with <code>--local github.com/spheric -w $FilePath$</code></li> </ul>"},{"location":"development/setup/#cleanup","title":"Cleanup","text":"<p>To remove the APIs from your cluster, simply run</p> <pre><code>make uninstall\n</code></pre>"},{"location":"development/testing/","title":"Testing","text":"<p>This project is using Ginkgo as it's primary testing framework in conjunction with Gomega matcher/assertion library.</p>"},{"location":"development/testing/#unit-tests","title":"Unit Tests","text":"<p>Each package should consist of its own <code>suite_test</code> setup and the corresponding test cases for each component.</p> <p>Example of test suite setup is below:</p> <pre><code>package mypackage\n\nimport (\n    . \"github.com/onsi/ginkgo/v2\"\n    . \"github.com/onsi/gomega\"\n    \"testing\"\n)\n\nfunc Test(t *testing.T) {\n    RegisterFailHandler(ginkgo.Fail)\n    ginkgo.RunSpecs(t, \"MyComponent\")\n}\n</code></pre> <p>The testing code should meet the requirements of be common Ginkgo format</p> <pre><code>package mypackage\n\nimport\n...\n\nvar _ = Describe(\"MyComponent\", func() {\n\n    BeforeEach(func() {\n        // Code to run before each Context\n    })\n\n    Context(\"When doing x\", func() {\n        It(\"Should result in y\", func() {\n            By(\"Creating something in x\")\n            Expect(x.DoSomething()).To(Equal(\"expected result\"))\n        })\n    })\n})\n</code></pre> <p>Note</p> <p>here: Ginkgo documentation. Assertion examples can be found here: Gomega documentation.</p>"},{"location":"development/testing/#controller-tests","title":"Controller Tests","text":"<p>Setup a local Kubernetes control plane in order to write controller tests. Use <code>envtest</code> as a part of the controller-runtime project.</p> <p>Example of <code>suite_test.go</code> inside a controller package is below:</p> <pre><code>package my_controller_package\n\nimport\n...\n\n// Those global vars are needed later.\nvar cfg *rest.Config\nvar k8sClient client.Client\nvar testEnv *envtest.Environment\n\nfunc TestAPIs(t *testing.T) {\n    RegisterFailHandler(Fail)\n\n    RunSpecsWithDefaultAndCustomReporters(t,\n        \"Controller Suite\",\n        []Reporter{printer.NewlineReporter{}})\n}\n\nvar _ = BeforeSuite(func() {\n    ...\n    // Here is the actual envtest setup. Make sure that the path\n    // to your generated CRDs is correct, as it will be injected\n    // directly into the API server once the envtest environment comes up.\n    testEnv = &amp;envtest.Environment{\n        CRDDirectoryPaths:     []string{filepath.Join(\"..\", \"..\", \"..\", \"config\", \"crd\", \"bases\")},\n        ErrorIfCRDPathMissing: true,\n    }\n    ...\n    // Define scheme\n    err = api.AddToScheme(scheme.Scheme)\n    ...\n    // Create a corresponding Kubernetes client.\n    k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})\n    ...\n    k8sManager, err := manager.NewManager(cfg, ctrl.Options{\n        Scheme: scheme.Scheme,\n        // On MacOS it might happen, that the firewall warnings will\n        // popup if you open a port on your machine. It typically\n        // happens due to the metrics endpoint of the controller-manager.\n        // To prevent it, disable it in the local setup\n        // and set the Host parameter to localhost.\n        Host:               \"127.0.0.1\",\n        MetricsBindAddress: \"0\",\n    })\n    ...\n    // Register our reconciler with the manager. In case if you want to test\n    // multiple reconcilers at once you have to register them one by\n    // one in the same fashion as is shown below.\n    err = (&amp;MyObjectReconciler{\n        Client: k8sManager.GetClient(),\n        Scheme: k8sManager.GetScheme(),\n        Log:    ctrl.Log.WithName(\"controllers\").WithName(\"MyObject\"),\n    }).SetupWithManager(k8sManager)\n    ...\n\n    // Start the manager\n    go func() {\n        err = k8sManager.Manager.Start(ctrl.SetupSignalHandler())\n        Expect(err).ToNot(HaveOccurred())\n    }()\n\n}, 60)\n\nvar _ = AfterSuite(func() {\n    By(\"tearing down the test environment\")\n    err := testEnv.Stop()\n    Expect(err).NotTo(HaveOccurred())\n})\n</code></pre> <p>The Ginkgo style tests can be now written in the same manner as described in the Unit Test section. The only difference now is, that you have a working controller manager in the background which is reacting on changes in the Kubernetes API which you can access via the <code>k8sClient</code> to create or modify your resources.</p> <p>More information on the envtest setup you can find in the CRD testing section here: Kubebuilder</p>"},{"location":"development/testing/#webhook-tests","title":"Webhook Tests","text":"<p>Webhook tests are located under <code>pkg/webhooks/{Type}</code>. The <code>suite_test</code> for Webhooks is slighly different than the controller suite.</p> <pre><code>// Register admission types\nerr = admissionv1beta1.AddToScheme(scheme)\n...\n// Start webhook server using Manager\nwebhookInstallOptions := &amp;testEnv.WebhookInstallOptions\nmgr, err := manager.NewManager(cfg, ctrl.Options{\nScheme:             scheme,\nHost:               webhookInstallOptions.LocalServingHost,\nPort:               webhookInstallOptions.LocalServingPort,\nCertDir:            webhookInstallOptions.LocalServingCertDir,\nLeaderElection:     false,\nMetricsBindAddress: \"0\",\n})\n...\n// Setup webhook with manager\nerr = (&amp;FooWebhook{}).SetupWebhookWithManager(mgr)\n...\n// Wait for the webhook server to get ready\ndialer := &amp;net.Dialer{Timeout: time.Second}\naddrPort := fmt.Sprintf(\"%s:%d\", webhookInstallOptions.LocalServingHost,\nwebhookInstallOptions.LocalServingPort)\nEventually(func () error {\nconn, err := tls.DialWithDialer(dialer, \"tcp\", addrPort,\n&amp;tls.Config{InsecureSkipVerify: true})\nif err != nil {\nreturn err\n}\nconn.Close()\nreturn nil\n}).Should(Succeed())\n</code></pre> <p>Test cases are written in a similar fashion as tests for controllers.</p> <p>!!! note MutatingWebhooks (<code>Defaulter</code>) can not change <code>Status</code> fields. Keep this in mind if you write your Webhook tests.</p>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":"<p>Test run can be executed via:</p> <pre><code>make test\n</code></pre>"},{"location":"development/testing/#goland-integration","title":"Goland Integration","text":"<p>Running static Ginkgo/Gomega tests in Golang should work out of the box. However, in order to make the controller test run from within your IDE you need to expose the following environment variable inside your 'Test Run Configuration'</p> <pre><code>KUBEBUILDER_ASSETS=/PATH_TO_MY_WORKSPACE/spheric-cloud/spheric/testbin/bin\n</code></pre> <p>This is typically the location of the Kubernetes control plane binaries on your machine.</p>"},{"location":"proposals/","title":"Proposals","text":"<p>This is the home of the <code>spheric</code> enhancement/extension proposals. You can find the list of accepted proposals  in the poposal folder of our Github repository.</p>"},{"location":"proposals/#submitting-a-new-proposal","title":"Submitting a new proposal","text":"<p>Please use our proposal template to write and submit your proposal via a pull request. </p>"},{"location":"proposals/00-template/","title":"SEP-NNNN: Your short, descriptive title","text":""},{"location":"proposals/00-template/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/00-template/#summary","title":"Summary","text":""},{"location":"proposals/00-template/#motivation","title":"Motivation","text":""},{"location":"proposals/00-template/#goals","title":"Goals","text":""},{"location":"proposals/00-template/#non-goals","title":"Non-Goals","text":""},{"location":"proposals/00-template/#proposal","title":"Proposal","text":""},{"location":"proposals/00-template/#alternatives","title":"Alternatives","text":""}]}